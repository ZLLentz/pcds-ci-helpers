name: Pip Build

on:
  workflow_call:
    inputs:
      package-name:
        default: ""
        description: "The package name"
        required: false
        type: string
      python-version:
        description: "The Python version to build and test with"
        required: true
        type: string
      experimental:
        description: "Mark this version as experimental and not required to pass"
        required: false
        default: false
        type: boolean
      testing-extras:
        default: ""
        description: "Extra packages to be installed for testing"
        required: false
        type: string
      ci-extras:
        default: "pytest-cov"
        description: "CI-specific packages to be installed"
        required: false
        type: string
      requirements-file:
        default: "dev-requirements.txt"
        description: "Development requirements filename"
        required: false
        type: string
    outputs: {}

env:
  MPLBACKEND: "agg"
  QT_QPA_PLATFORM: "offscreen"

jobs:
  build-and-test:
    name: "Pip test with Python ${{ inputs.python-version }}"
    runs-on: ubuntu-20.04
    continue-on-error: ${{ inputs.experimental }}

    defaults:
      run:
        # The following allows for each run step to utilize ~/.bash_profile
        # for setting up the per-step initial state.
        # --login: a login shell. Source ~/.bash_profile
        # -e: exit on first error
        # -o pipefail: piped processes are important; fail if they fail
        shell: bash --login -eo pipefail {0}

    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Check version to be built
      run: |
        # NOTE: If you run CI on your own fork, you may not have the right version
        # number for the package. Synchronize your tags with the upstream,
        # otherwise cross-dependencies may result in confusing build failure.
        (echo "Package version: $(git describe --tags)" | tee "$GITHUB_STEP_SUMMARY") || \
          echo "::warning::Git tags not found in repository. Build may fail!"

    - name: Determine package name if unset
      run: |
        if [[ -n "${{ inputs.package-name }}" ]]; then
          package_name="${{ inputs.package-name }}"
          echo "Package name specified as a workflow input"
        else
          if [[ -n "${{ github.base_ref }}" ]]; then
            repo="${{ github.base_ref }}"
          else
            repo="${{ github.repository }}"
          fi
          owner=$(dirname "$repo")
          package_name=$(basename "$repo")
        fi

        set -xe
        echo "package_name=${package_name}" >> "$GITHUB_ENV"

    - name: Check environment variables for issues
      run: |
        echo "* Package to be built: ${package_name}"
        echo "* Pip 'extras' for CI testing: ${{ inputs.testing-extras }}"
        echo "* General pip packages required for CI testing: ${{ inputs.ci-extras }}"

    - name: Prepare for log files
      run: |
        mkdir $HOME/logs

    - uses: actions/setup-python@v4
      with:
        python-version: '${{ inputs.python-version }}'

    - name: Upgrade pip
      run: |
        pip install --upgrade pip

    - name: Installing package
      run: |
        pip install .

    - name: Installing CI extras and testing extras
      run: |
        # 1. escape '<' so the user doesn't have to
        # 2. escape '>' so the user doesn't have to
        # 3. allow conda/pip to use the same requirements spec;
        # conda expects pkg=ver but pip expects pkg==ver; using a basic
        # (not =)=(not =) to avoid incompatibility with macOS sed not supporting
        # '=\+'
        input_requirements=$(
          echo "${{ inputs.ci-extras }} ${{ inputs.testing-extras }}" |
          sed -e "s/</\</g" |
          sed -e "s/>/\>/g" |
          sed -e 's/\([^=]\)=\([^=]\)/\1==\2/g'
        )

        declare -a test_requirements=()
        for req in $input_requirements; do
          test_requirements+=( "$req" )
        done

        if [[ ${#test_requirements[@]} -gt 0 ]]; then
          echo "CI extras: ${{ inputs.ci-extras }}"
          echo "Testing extras: ${{ inputs.testing-extras }}"
          set -x
          pip install "${test_requirements[@]}"
        else
          echo "No extras to install."
        fi

    - name: Installing development requirements
      run: |
        if [ -n "${{ inputs.requirements-file }}" ]; then
          echo "Requirements file: ${{ inputs.requirements-file }}"
          pip install --requirement "${{ inputs.requirements-file }}"
        else
          echo "No requirements file configured."
        fi

    - name: Check the pip packages in the test env
      run: |
        pip list

    - name: Run tests
      run: |
        pytest -v \
          --cov=. \
          --log-file="$HOME/logs/debug_log.txt" \
          --log-format='%(asctime)s.%(msecs)03d %(module)-15s %(levelname)-8s %(threadName)-10s %(message)s' \
          --log-file-date-format='%H:%M:%S' \
          --log-level=DEBUG \
          2>&1 | tee "$HOME/logs/pytest_log.txt"

    - name: After failure
      if: ${{ failure() }}
      run: |
        # On failure:
        # * Include the pip package details
        # * Include the pytest log in the step summary (but not in the step output as it's available in the previous step)
        # * Include the debug log in the step output (but not the step summary as it's too verbose)
        (
          echo "## Failure debugging"
          echo "### Pip list"
          echo "```"
          pip list | egrep -v -e "^#"
          echo "```"

          echo "### Pytest log"
          echo "```python"
          cat "$HOME/logs/pytest_log.txt" || echo "# Pytest log not found?"
          echo "```"
        ) >> "$GITHUB_STEP_SUMMARY"

        echo "## Debug log"
        cat "$HOME/logs/debug_log.txt" || echo "Debug logfile not found?"

    - name: Upload log file artifacts
      if: ${{ always() }}
      uses: actions/upload-artifact@v3
      with:
        name: Python ${{ inputs.python-version }} - pip - testing log
        path: "~/logs"
        retention-days: 30
